# coding: utf-8

"""
    CampaignManagementService

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from openapi_client.models.campaign.bid import Bid
from openapi_client.models.campaign.commission_bidding_scheme import CommissionBiddingScheme
from openapi_client.models.campaign.cost_per_sale_bidding_scheme import CostPerSaleBiddingScheme
from openapi_client.models.campaign.enhanced_cpc_bidding_scheme import EnhancedCpcBiddingScheme
from openapi_client.models.campaign.inherit_from_parent_bidding_scheme import InheritFromParentBiddingScheme
from openapi_client.models.campaign.manual_cpa_bidding_scheme import ManualCpaBiddingScheme
from openapi_client.models.campaign.manual_cpc_bidding_scheme import ManualCpcBiddingScheme
from openapi_client.models.campaign.manual_cpm_bidding_scheme import ManualCpmBiddingScheme
from openapi_client.models.campaign.manual_cpv_bidding_scheme import ManualCpvBiddingScheme
from openapi_client.models.campaign.max_clicks_bidding_scheme import MaxClicksBiddingScheme
from openapi_client.models.campaign.max_conversion_value_bidding_scheme import MaxConversionValueBiddingScheme
from openapi_client.models.campaign.max_conversions_bidding_scheme import MaxConversionsBiddingScheme
from openapi_client.models.campaign.max_roas_bidding_scheme import MaxRoasBiddingScheme
from openapi_client.models.campaign.percent_cpc_bidding_scheme import PercentCpcBiddingScheme
from openapi_client.models.campaign.target_cpa_bidding_scheme import TargetCpaBiddingScheme
from openapi_client.models.campaign.target_impression_share_bidding_scheme import TargetImpressionShareBiddingScheme
from openapi_client.models.campaign.target_roas_bidding_scheme import TargetRoasBiddingScheme
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

BiddingScheme_ONE_OF_SCHEMAS = ["CommissionBiddingScheme", "CostPerSaleBiddingScheme", "EnhancedCpcBiddingScheme", "InheritFromParentBiddingScheme", "ManualCpaBiddingScheme", "ManualCpcBiddingScheme", "ManualCpmBiddingScheme", "ManualCpvBiddingScheme", "MaxClicksBiddingScheme", "MaxConversionValueBiddingScheme", "MaxConversionsBiddingScheme", "MaxRoasBiddingScheme", "PercentCpcBiddingScheme", "TargetCpaBiddingScheme", "TargetImpressionShareBiddingScheme", "TargetRoasBiddingScheme"]

class BiddingScheme(BaseModel):
    """
    BiddingScheme
    """
    # data type: CommissionBiddingScheme
    oneof_schema_commission_bidding_scheme_validator: Optional[CommissionBiddingScheme] = None
    # data type: CostPerSaleBiddingScheme
    oneof_schema_cost_per_sale_bidding_scheme_validator: Optional[CostPerSaleBiddingScheme] = None
    # data type: EnhancedCpcBiddingScheme
    oneof_schema_enhanced_cpc_bidding_scheme_validator: Optional[EnhancedCpcBiddingScheme] = None
    # data type: InheritFromParentBiddingScheme
    oneof_schema_inherit_from_parent_bidding_scheme_validator: Optional[InheritFromParentBiddingScheme] = None
    # data type: ManualCpaBiddingScheme
    oneof_schema_manual_cpa_bidding_scheme_validator: Optional[ManualCpaBiddingScheme] = None
    # data type: ManualCpcBiddingScheme
    oneof_schema_manual_cpc_bidding_scheme_validator: Optional[ManualCpcBiddingScheme] = None
    # data type: ManualCpmBiddingScheme
    oneof_schema_manual_cpm_bidding_scheme_validator: Optional[ManualCpmBiddingScheme] = None
    # data type: ManualCpvBiddingScheme
    oneof_schema_manual_cpv_bidding_scheme_validator: Optional[ManualCpvBiddingScheme] = None
    # data type: MaxClicksBiddingScheme
    oneof_schema_max_clicks_bidding_scheme_validator: Optional[MaxClicksBiddingScheme] = None
    # data type: MaxConversionValueBiddingScheme
    oneof_schema_max_conversion_value_bidding_scheme_validator: Optional[MaxConversionValueBiddingScheme] = None
    # data type: MaxConversionsBiddingScheme
    oneof_schema_max_conversions_bidding_scheme_validator: Optional[MaxConversionsBiddingScheme] = None
    # data type: MaxRoasBiddingScheme
    oneof_schema_max_roas_bidding_scheme_validator: Optional[MaxRoasBiddingScheme] = None
    # data type: PercentCpcBiddingScheme
    oneof_schema_percent_cpc_bidding_scheme_validator: Optional[PercentCpcBiddingScheme] = None
    # data type: TargetCpaBiddingScheme
    oneof_schema_target_cpa_bidding_scheme_validator: Optional[TargetCpaBiddingScheme] = None
    # data type: TargetImpressionShareBiddingScheme
    oneof_schema_target_impression_share_bidding_scheme_validator: Optional[TargetImpressionShareBiddingScheme] = None
    # data type: TargetRoasBiddingScheme
    oneof_schema_target_roas_bidding_scheme_validator: Optional[TargetRoasBiddingScheme] = None
    actual_instance: Optional[Union[CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme]] = None
    one_of_schemas: Set[str] = { "CommissionBiddingScheme", "CostPerSaleBiddingScheme", "EnhancedCpcBiddingScheme", "InheritFromParentBiddingScheme", "ManualCpaBiddingScheme", "ManualCpcBiddingScheme", "ManualCpmBiddingScheme", "ManualCpvBiddingScheme", "MaxClicksBiddingScheme", "MaxConversionValueBiddingScheme", "MaxConversionsBiddingScheme", "MaxRoasBiddingScheme", "PercentCpcBiddingScheme", "TargetCpaBiddingScheme", "TargetImpressionShareBiddingScheme", "TargetRoasBiddingScheme" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )

    discriminator_value_class_map: Dict[str, str] = {
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        if v is None:
            return v

        instance = BiddingScheme.model_construct()
        error_messages = []
        match = 0
        # validate data type: CommissionBiddingScheme
        if not isinstance(v, CommissionBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `CommissionBiddingScheme`")
        else:
            match += 1
        # validate data type: CostPerSaleBiddingScheme
        if not isinstance(v, CostPerSaleBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `CostPerSaleBiddingScheme`")
        else:
            match += 1
        # validate data type: EnhancedCpcBiddingScheme
        if not isinstance(v, EnhancedCpcBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `EnhancedCpcBiddingScheme`")
        else:
            match += 1
        # validate data type: InheritFromParentBiddingScheme
        if not isinstance(v, InheritFromParentBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `InheritFromParentBiddingScheme`")
        else:
            match += 1
        # validate data type: ManualCpaBiddingScheme
        if not isinstance(v, ManualCpaBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ManualCpaBiddingScheme`")
        else:
            match += 1
        # validate data type: ManualCpcBiddingScheme
        if not isinstance(v, ManualCpcBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ManualCpcBiddingScheme`")
        else:
            match += 1
        # validate data type: ManualCpmBiddingScheme
        if not isinstance(v, ManualCpmBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ManualCpmBiddingScheme`")
        else:
            match += 1
        # validate data type: ManualCpvBiddingScheme
        if not isinstance(v, ManualCpvBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ManualCpvBiddingScheme`")
        else:
            match += 1
        # validate data type: MaxClicksBiddingScheme
        if not isinstance(v, MaxClicksBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MaxClicksBiddingScheme`")
        else:
            match += 1
        # validate data type: MaxConversionValueBiddingScheme
        if not isinstance(v, MaxConversionValueBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MaxConversionValueBiddingScheme`")
        else:
            match += 1
        # validate data type: MaxConversionsBiddingScheme
        if not isinstance(v, MaxConversionsBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MaxConversionsBiddingScheme`")
        else:
            match += 1
        # validate data type: MaxRoasBiddingScheme
        if not isinstance(v, MaxRoasBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `MaxRoasBiddingScheme`")
        else:
            match += 1
        # validate data type: PercentCpcBiddingScheme
        if not isinstance(v, PercentCpcBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `PercentCpcBiddingScheme`")
        else:
            match += 1
        # validate data type: TargetCpaBiddingScheme
        if not isinstance(v, TargetCpaBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TargetCpaBiddingScheme`")
        else:
            match += 1
        # validate data type: TargetImpressionShareBiddingScheme
        if not isinstance(v, TargetImpressionShareBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TargetImpressionShareBiddingScheme`")
        else:
            match += 1
        # validate data type: TargetRoasBiddingScheme
        if not isinstance(v, TargetRoasBiddingScheme):
            error_messages.append(f"Error! Input type `{type(v)}` is not `TargetRoasBiddingScheme`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in BiddingScheme with oneOf schemas: CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in BiddingScheme with oneOf schemas: CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: Optional[str]) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        if json_str is None:
            return instance

        error_messages = []
        match = 0

        # use oneOf discriminator to lookup the data type
        _data_type = json.loads(json_str).get("Type")
        if not _data_type:
            raise ValueError("Failed to lookup data type from the field `Type` in the input.")

		# check if data type is `CommissionBiddingScheme`
        if _data_type == "CommissionBiddingScheme":
            instance.actual_instance = CommissionBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `CostPerSaleBiddingScheme`
        if _data_type == "CostPerSale":
            instance.actual_instance = CostPerSaleBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `EnhancedCpcBiddingScheme`
        if _data_type == "EnhancedCpc":
            instance.actual_instance = EnhancedCpcBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `InheritFromParentBiddingScheme`
        if _data_type == "InheritFromParent":
            instance.actual_instance = InheritFromParentBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpaBiddingScheme`
        if _data_type == "ManualCpaBiddingScheme":
            instance.actual_instance = ManualCpaBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpcBiddingScheme`
        if _data_type == "ManualCpc":
            instance.actual_instance = ManualCpcBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpmBiddingScheme`
        if _data_type == "ManualCpm":
            instance.actual_instance = ManualCpmBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpvBiddingScheme`
        if _data_type == "ManualCpv":
            instance.actual_instance = ManualCpvBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxClicksBiddingScheme`
        if _data_type == "MaxClicks":
            instance.actual_instance = MaxClicksBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxConversionValueBiddingScheme`
        if _data_type == "MaxConversionValueBiddingScheme":
            instance.actual_instance = MaxConversionValueBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxConversionsBiddingScheme`
        if _data_type == "MaxConversions":
            instance.actual_instance = MaxConversionsBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxRoasBiddingScheme`
        if _data_type == "MaxRoasBiddingScheme":
            instance.actual_instance = MaxRoasBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `PercentCpcBiddingScheme`
        if _data_type == "PercentCpcBiddingScheme":
            instance.actual_instance = PercentCpcBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `TargetCpaBiddingScheme`
        if _data_type == "TargetCpa":
            instance.actual_instance = TargetCpaBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `TargetImpressionShareBiddingScheme`
        if _data_type == "TargetImpressionShareBiddingScheme":
            instance.actual_instance = TargetImpressionShareBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `TargetRoasBiddingScheme`
        if _data_type == "TargetRoasBiddingScheme":
            instance.actual_instance = TargetRoasBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `CostPerSaleBiddingScheme`
        if _data_type == "CostPerSaleBiddingScheme":
            instance.actual_instance = CostPerSaleBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `EnhancedCpcBiddingScheme`
        if _data_type == "EnhancedCpcBiddingScheme":
            instance.actual_instance = EnhancedCpcBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `InheritFromParentBiddingScheme`
        if _data_type == "InheritFromParentBiddingScheme":
            instance.actual_instance = InheritFromParentBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpcBiddingScheme`
        if _data_type == "ManualCpcBiddingScheme":
            instance.actual_instance = ManualCpcBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpmBiddingScheme`
        if _data_type == "ManualCpmBiddingScheme":
            instance.actual_instance = ManualCpmBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `ManualCpvBiddingScheme`
        if _data_type == "ManualCpvBiddingScheme":
            instance.actual_instance = ManualCpvBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxClicksBiddingScheme`
        if _data_type == "MaxClicksBiddingScheme":
            instance.actual_instance = MaxClicksBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `MaxConversionsBiddingScheme`
        if _data_type == "MaxConversionsBiddingScheme":
            instance.actual_instance = MaxConversionsBiddingScheme.from_json(json_str)
            return instance
			
		# check if data type is `TargetCpaBiddingScheme`
        if _data_type == "TargetCpaBiddingScheme":
            instance.actual_instance = TargetCpaBiddingScheme.from_json(json_str)
            return instance
			

        # deserialize data into CommissionBiddingScheme
        try:
            instance.actual_instance = CommissionBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into CostPerSaleBiddingScheme
        try:
            instance.actual_instance = CostPerSaleBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into EnhancedCpcBiddingScheme
        try:
            instance.actual_instance = EnhancedCpcBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into InheritFromParentBiddingScheme
        try:
            instance.actual_instance = InheritFromParentBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ManualCpaBiddingScheme
        try:
            instance.actual_instance = ManualCpaBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ManualCpcBiddingScheme
        try:
            instance.actual_instance = ManualCpcBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ManualCpmBiddingScheme
        try:
            instance.actual_instance = ManualCpmBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ManualCpvBiddingScheme
        try:
            instance.actual_instance = ManualCpvBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MaxClicksBiddingScheme
        try:
            instance.actual_instance = MaxClicksBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MaxConversionValueBiddingScheme
        try:
            instance.actual_instance = MaxConversionValueBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MaxConversionsBiddingScheme
        try:
            instance.actual_instance = MaxConversionsBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into MaxRoasBiddingScheme
        try:
            instance.actual_instance = MaxRoasBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into PercentCpcBiddingScheme
        try:
            instance.actual_instance = PercentCpcBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into TargetCpaBiddingScheme
        try:
            instance.actual_instance = TargetCpaBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into TargetImpressionShareBiddingScheme
        try:
            instance.actual_instance = TargetImpressionShareBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into TargetRoasBiddingScheme
        try:
            instance.actual_instance = TargetRoasBiddingScheme.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into BiddingScheme with oneOf schemas: CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into BiddingScheme with oneOf schemas: CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], CommissionBiddingScheme, CostPerSaleBiddingScheme, EnhancedCpcBiddingScheme, InheritFromParentBiddingScheme, ManualCpaBiddingScheme, ManualCpcBiddingScheme, ManualCpmBiddingScheme, ManualCpvBiddingScheme, MaxClicksBiddingScheme, MaxConversionValueBiddingScheme, MaxConversionsBiddingScheme, MaxRoasBiddingScheme, PercentCpcBiddingScheme, TargetCpaBiddingScheme, TargetImpressionShareBiddingScheme, TargetRoasBiddingScheme]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())

    def __getattr__(self, name):
        """Forward attribute access to actual_instance"""
        if self.actual_instance is not None and hasattr(self.actual_instance, name):
            return getattr(self.actual_instance, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        """Forward attribute setting to actual_instance"""
        if name in ['actual_instance', 'oneof_schema_commission_bidding_scheme_validator', 'oneof_schema_cost_per_sale_bidding_scheme_validator', 'oneof_schema_enhanced_cpc_bidding_scheme_validator', 'oneof_schema_inherit_from_parent_bidding_scheme_validator', 'oneof_schema_manual_cpa_bidding_scheme_validator', 'oneof_schema_manual_cpc_bidding_scheme_validator', 'oneof_schema_manual_cpm_bidding_scheme_validator', 'oneof_schema_manual_cpv_bidding_scheme_validator', 'oneof_schema_max_clicks_bidding_scheme_validator', 'oneof_schema_max_conversion_value_bidding_scheme_validator', 'oneof_schema_max_conversions_bidding_scheme_validator', 'oneof_schema_max_roas_bidding_scheme_validator', 'oneof_schema_percent_cpc_bidding_scheme_validator', 'oneof_schema_target_cpa_bidding_scheme_validator', 'oneof_schema_target_impression_share_bidding_scheme_validator', 'oneof_schema_target_roas_bidding_scheme_validator', 'one_of_schemas', 'model_config', 'discriminator_value_class_map']:
            super().__setattr__(name, value)
        elif self.actual_instance is not None and hasattr(self.actual_instance, name):
            setattr(self.actual_instance, name, value)
        else:
            super().__setattr__(name, value)
